#!/usr/bin/env ruby
# frozen_string_literal: true

require 'English'
require 'cgi'
require 'fileutils'
require 'json'

def reset
  execute('git checkout .changes CHANGELOG.md .version Gemfile.lock')
end

Signal.trap('INT') do
  reset
end

Signal.trap('TERM') do
  reset
end

def fail(msg)
  warn("Fatal: #{msg}")
  reset
  exit(1)
end

def execute(command)
  result = `#{command} 2> /dev/null`.strip
  fail("#{command} failed") unless $CHILD_STATUS.success?

  result
end

# Represents a library version like 1.0.0.
class Version
  include Comparable

  attr_reader :major, :minor, :patch

  def initialize(major, minor, patch)
    @major = major
    @minor = minor
    @patch = patch
  end

  def self.parse(version)
    parts = version.split('.')
    raise ArgumentError, "invalid version: #{version}" unless parts.size == 3

    major = Integer(parts[0])
    minor = Integer(parts[1])
    patch = Integer(parts[2])

    Version.new(major, minor, patch)
  end

  def <=>(other)
    if (major <=> other.major) != 0
      major <=> other.major
    elsif (minor <=> other.minor) != 0
      minor <=> other.minor
    else
      patch <=> other.patch
    end
  end

  def to_s
    "#{major}.#{minor}.#{patch}"
  end
end

old_version = File.read('.version')

# Parse version argument.
fail("you must specify the version to be released, the previous version was #{old_version}") if ARGV.length != 1

begin
  new_version = Version.parse(ARGV[0])
rescue ArgumentError
  fail("invalid version: #{ARGV[0]}")
end

# Compare new version to previous version.
previous_version = Version.parse(old_version)
unless new_version > previous_version
  fail("new version (#{new_version}) must be greater than previous version (#{previous_version})")
end

# Read changelog
versions = File.read('.changes').split(/(?=^version:)/).to_h do |content|
  lines = content.strip.split("\n")
  version = lines[0].gsub(/^version: */, '').strip
  version = if version == 'next'
              new_version
            else
              Version.parse(version)
            end
  description = lines[1..].join("\n")
  description = '- No changes' if description.empty?
  [version, description]
end
new_changelog = versions[new_version]
fail('"next" version not found in changelog') unless new_changelog

# Check whether there are any local changes.
fail('stage or commit your changes') unless execute('git status --porcelain').empty?

# Get current branch.
execute('git fetch')
branch = execute('git branch --show-current')
fail('cannot determine current branch') if branch.empty?

# Get repo default branch.
default_branch = execute('git symbolic-ref refs/remotes/origin/HEAD')
fail('cannot determine default branch') unless default_branch.match?(%r{^refs/remotes/origin/[^/]+$})

default_branch = default_branch.gsub(%r{^refs/remotes/origin/}, '')

# Ensure we are on the repo's default branch. We don't want to release from a feature branch.
fail("you must release from the #{default_branch} branch") unless branch == default_branch

# Ensure we are on the latest remote commit.
local_commit = execute("git rev-parse #{branch}")
remote_commit = execute("git rev-parse origin/#{branch}")
fail("#{default_branch} is behind or ahead, you must pull or push") unless local_commit == remote_commit

# Ensure the GitHub command is installed.
success = system('which gh 1> /dev/null 2> /dev/null')
fail('gh command not found, see https://github.com/cli/cli') unless success

# Print versions as a sanity check.
puts "Previous version: #{previous_version}"
puts "Release version: #{new_version}"

# Install, build and lint
puts
puts 'Cleaning'
execute('make clean')
puts 'Installing'
execute('make install')
puts 'Building'
execute('make build')
puts 'Linting'
execute('make lint')

# Run tests
puts 'Testing'
execute('make test')
execute('make kill')

# Update the version in .version
puts 'Updating .version'
File.write('.version', new_version)

# Update the changelog
changelogs = versions.map do |version, changelog|
  "version: #{version}\n#{changelog}\n\n"
end
File.write('.changes', "version: next\n\n#{changelogs.join.strip}\n")

# Update CHANGELOG.md
changelogs = versions.map do |version, changelog|
  "## #{version}\n\n#{changelog}\n\n"
end
File.write('CHANGELOG.md', "# Changes\n\n#{changelogs.join.strip}\n")

# Build gem.
gem_file = "sqlui-#{new_version}.gem"
FileUtils.rm_f(gem_file)
puts "Building #{gem_file}"
execute('gem build')
fail("Gem file not found: #{gem_file}") unless File.exist?(gem_file)

# Bundle install so that Gemfile.lock contains the new version.
execute('bundle install')

# Prompt to confirm we want to release.
puts
puts "Ready to release version #{new_version}"
puts 'Changes:'
puts new_changelog
puts
$stderr.print('Proceed? ')
begin
  unless %w[y yes ja yep].include?($stdin.gets.chomp.downcase)
    puts 'Aborting'
    reset
    exit
  end
rescue Interrupt
  puts
  puts 'Aborting'
  reset
  exit
end

puts

# Relase the gem. Use system to allow for login.
success = system("gem push #{gem_file}")
fail('gem push failed') unless success

# Commit the changes (version.rb and Gemfile.lock)
puts
puts 'Pushing release commit'
execute("git commit -a -m 'v#{new_version} release' -m \"#{new_changelog}\"")
execute("git tag v#{new_version}")
execute("git push origin v#{new_version}")
execute('git push')

# Build GitHub release URL.
target_commit = execute('git rev-parse HEAD')
notes = <<~MARKDOWN
  ### Features & Bug Fixes
  #{new_changelog}
MARKDOWN

puts
puts 'Creating GitHub release'
success = system("gh release create v#{new_version} " \
                 "--title 'v#{new_version} Release' " \
                 "--notes \"#{notes}\" " \
                 "--target '#{target_commit}' " \
                 "'sqlui-#{new_version}.gem'")
fail('gh release create failed') unless success

git_url = "https://github.com/nicholasdower/sqlui/releases/tag/v#{new_version}"

# Print success and GitHub instructions.
puts
puts "Version #{new_version} successfully released"

# If on a Mac, open the browser.
execute("open \"#{git_url}\"") if system('which open 1> /dev/null 2> /dev/null')
