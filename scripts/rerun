#!/usr/bin/env ruby
# frozen_string_literal: true

require 'find'
require 'optparse'
require 'set'

# Runs the specified command and restarts it when files in the specified directories change.
class Watcher
  MIN_REFRESH_DELAY = 2

  def initialize(paths, command)
    raise 'missing paths' unless paths&.any?
    raise 'missing command' unless command&.any?

    @exclusions, @paths = paths.partition { |p| p.start_with?('!') }
    @exclusions = @exclusions.map do |s|
      raise 'directories may not be excluded, it is too hard to implement ;)' if File.directory?(s)

      s[1..]
    end

    @command = command
    @watched_files = watched_files
    @alive = true
    @last_change = Time.now
  end

  def watch
    @pid = Process.spawn(*@command, pgroup: true) if @alive
    while @alive
      minutes_since_last_change = ((Time.now - @last_change) / 60).to_i
      minutes_since_last_change = [minutes_since_last_change, 0].max
      delay = [60, 20, 10, 5, 0].find { |t| minutes_since_last_change >= t }
      delay = [delay, MIN_REFRESH_DELAY].max
      sleep delay
      refresh
    end
  end

  def refresh
    files = updated_files
    return if files.empty?

    puts "changed: #{files.join(' ')}"
    @last_change = Time.now
    kill('TERM')
    @pid = Process.spawn(*@command, pgroup: true) if @alive
  end

  def kill(signal)
    return unless @pid

    Process.kill(signal, -Process.getpgid(@pid))
  rescue Errno::ESRCH
    # ignore
  ensure
    @pid = nil
  end

  def die(signal)
    kill(signal)
    @alive = false
  end

  def watched_files
    files = Find.find(*@paths).to_a - @exclusions
    entries = files.flat_map do |file|
      if FileTest.file?(file)
        [[file, File.mtime(file).to_i]]
      else
        []
      end
    end
    entries.to_set
  end

  def updated_files
    new_watched_files = watched_files
    difference = (new_watched_files - @watched_files) + (@watched_files - new_watched_files)
    @watched_files = new_watched_files
    difference.map(&:first)
  end
end

separator = ARGV.find_index('--')
unless separator&.between?(1, ARGV.size - 2)
  warn 'Usage: ./scripts/rerun path... -- <command>'
  exit 1
end
paths = ARGV[0...separator]
command = ARGV[(separator + 1)..]
watcher = Watcher.new(paths, command)

Signal.trap('INT') do
  watcher.die('INT')
  exit 2
end

Signal.trap('TERM') do
  watcher.die('TERM')
  exit 15
end
watcher.watch
